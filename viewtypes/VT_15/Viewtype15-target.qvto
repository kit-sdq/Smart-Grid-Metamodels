/* Generated ModelJoin transformation 
 *
 */
transformation M1toM2(
in __CIM: _CIM, 
in __substationStandard: _substationStandard, 
in __COSEM: _COSEM, 
out __jointarget: _jointarget,
out __mjtrace: _mjtrace);	
	
// source metamodels
modeltype _CIM uses "http://iec.ch/TC57/2009/CIM-schema-cim14";
modeltype _substationStandard uses "substationStandard";
modeltype _COSEM uses "cosem";
// target metamodel
modeltype _jointarget uses "ApparentPowerPhaseMeasurements";
// trace metamodel
modeltype _mjtrace uses "ApparentPowerPhaseMeasurements.trace";
	
//alway import ecore
modeltype ECORE "strict" uses ecore('http://www.eclipse.org/emf/2002/Ecore');

main() {
-- ###
-- # operations for target class PMUApparentPowerMeter
-- ##

-- get all elements of of type MeterAsset and MMXU
var leftAllPMUApparentPowerMeter = __CIM.objectsOfType(_CIM::IEC61968::Metering::MeterAsset);
var rightAllPMUApparentPowerMeter = __substationStandard.objectsOfType(_substationStandard::LNNodes::LNGroupM::MMXU);

-- theta join operation
rightAllPMUApparentPowerMeter->forEach(rightPMUApparentPowerMeter) {
	leftAllPMUApparentPowerMeter->map thetaJoin_MeterAsset_MMXU_To_PMUApparentPowerMeter(rightPMUApparentPowerMeter);
};
-- ###
-- # operations for target class PrivateMeterApparentPower
-- ##

-- get all elements of of type MeterAsset and PhysicalDevice
var leftAllPrivateMeterApparentPower = __CIM.objectsOfType(_CIM::IEC61968::Metering::MeterAsset);
var rightAllPrivateMeterApparentPower = __COSEM.objectsOfType(_COSEM::PhysicalDevice);

-- theta join operation
rightAllPrivateMeterApparentPower->forEach(rightPrivateMeterApparentPower) {
	leftAllPrivateMeterApparentPower->map thetaJoin_MeterAsset_PhysicalDevice_To_PrivateMeterApparentPower(rightPrivateMeterApparentPower);
};


	-- keep outgoing references


	var refAllLocation_715feccf_600b_4a56_8b0c_1608f4564bc8 = __jointarget.objectsOfType(_jointarget::Asset);
	refAllLocation_715feccf_600b_4a56_8b0c_1608f4564bc8->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61968::Assets::Asset)->collect(Location)->selectByKind(_CIM::IEC61968::Common::Location)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_Location(refElem.resolveone(_jointarget::Location));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_Location(refElem);
			}endif;
			refElem.resolveone(_jointarget::Location).map trace_keepOutgoing_Location(refElem);
		};
	};
	-- keep outgoing references


	var refAllPosition_a4315327_2af9_4cca_bbbd_30824a9f1cb4 = __jointarget.objectsOfType(_jointarget::Location);
	refAllPosition_a4315327_2af9_4cca_bbbd_30824a9f1cb4->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61968::Common::Location)->collect(Position)->selectByKind(_CIM::IEC61968::Common::PositionPoint)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_Position(refElem.resolveone(_jointarget::PositionPoint));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_Position(refElem);
			}endif;
			refElem.resolveone(_jointarget::PositionPoint).map trace_keepOutgoing_Position(refElem);
		};
	};
	-- keep outgoing references


	var refAllPowerSystemResources_824c9bd3_4727_4211_bd86_f174434efaca = __jointarget.objectsOfType(_jointarget::Location);
	refAllPowerSystemResources_824c9bd3_4727_4211_bd86_f174434efaca->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61968::Common::Location)->collect(PowerSystemResources)->selectByKind(_CIM::IEC61970::Core::PowerSystemResource)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_PowerSystemResources(refElem.resolveone(_jointarget::PowerSystemResource));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_PowerSystemResources(refElem);
			}endif;
			refElem.resolveone(_jointarget::PowerSystemResource).map trace_keepOutgoing_PowerSystemResources(refElem);
		};
	};
	-- keep outgoing references


	var refAllTerminals_df32a7f5_f452_43ab_a884_db81eae2cdf9 = __jointarget.objectsOfType(_jointarget::ConductingEquipment);
	refAllTerminals_df32a7f5_f452_43ab_a884_db81eae2cdf9->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61970::Core::ConductingEquipment)->collect(Terminals)->selectByKind(_CIM::IEC61970::Core::Terminal)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_Terminals(refElem.resolveone(_jointarget::Terminal));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_Terminals(refElem);
			}endif;
			refElem.resolveone(_jointarget::Terminal).map trace_keepOutgoing_Terminals(refElem);
		};
	};
	-- keep outgoing references


	var refAllTieFlow_89bd523f_b07f_497d_a3aa_79159d4af22e = __jointarget.objectsOfType(_jointarget::Terminal);
	refAllTieFlow_89bd523f_b07f_497d_a3aa_79159d4af22e->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61970::Core::Terminal)->collect(TieFlow)->selectByKind(_CIM::IEC61970::ControlArea::TieFlow)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_TieFlow(refElem.resolveone(_jointarget::TieFlow));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_TieFlow(refElem);
			}endif;
			refElem.resolveone(_jointarget::TieFlow).map trace_keepOutgoing_TieFlow(refElem);
		};
	};
	-- keep outgoing references


	var refAllControlArea_27c2cb42_16dc_4e0b_b0a1_28399a6c0837 = __jointarget.objectsOfType(_jointarget::TieFlow);
	refAllControlArea_27c2cb42_16dc_4e0b_b0a1_28399a6c0837->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61970::ControlArea::TieFlow)->collect(ControlArea)->selectByKind(_CIM::IEC61970::ControlArea::ControlArea)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_ControlArea(refElem.resolveone(_jointarget::ControlArea));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_ControlArea(refElem);
			}endif;
			refElem.resolveone(_jointarget::ControlArea).map trace_keepOutgoing_ControlArea(refElem);
		};
	};
	-- keep outgoing references


	var refAllServiceDeliveryPoint_f7a48896_db6e_41d4_8aa8_7ec8c7f2434c = __jointarget.objectsOfType(_jointarget::EndDeviceAsset);
	refAllServiceDeliveryPoint_f7a48896_db6e_41d4_8aa8_7ec8c7f2434c->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61968::Metering::EndDeviceAsset)->collect(ServiceDeliveryPoint)->selectByKind(_CIM::IEC61968::Metering::ServiceDeliveryPoint)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_ServiceDeliveryPoint(refElem.resolveone(_jointarget::ServiceDeliveryPoint));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_ServiceDeliveryPoint(refElem);
			}endif;
			refElem.resolveone(_jointarget::ServiceDeliveryPoint).map trace_keepOutgoing_ServiceDeliveryPoint(refElem);
		};
	};
	-- keep outgoing references


	var refAllEnergyConsumer_1af4aed0_8591_42b1_8808_1d705b79814f = __jointarget.objectsOfType(_jointarget::ServiceDeliveryPoint);
	refAllEnergyConsumer_1af4aed0_8591_42b1_8808_1d705b79814f->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61968::Metering::ServiceDeliveryPoint)->collect(EnergyConsumer)->selectByKind(_CIM::IEC61970::Wires::EnergyConsumer)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_EnergyConsumer(refElem.resolveone(_jointarget::EnergyConsumer));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_EnergyConsumer(refElem);
			}endif;
			refElem.resolveone(_jointarget::EnergyConsumer).map trace_keepOutgoing_EnergyConsumer(refElem);
		};
	};
	-- keep outgoing references


	var refAllLoadGroup_a5ad53bd_b73a_4bdb_916e_c6bed912892d = __jointarget.objectsOfType(_jointarget::ConformLoad);
	refAllLoadGroup_a5ad53bd_b73a_4bdb_916e_c6bed912892d->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61970::LoadModel::ConformLoad)->collect(LoadGroup)->selectByKind(_CIM::IEC61970::LoadModel::ConformLoadGroup)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_LoadGroup(refElem.resolveone(_jointarget::ConformLoadGroup));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_LoadGroup(refElem);
			}endif;
			refElem.resolveone(_jointarget::ConformLoadGroup).map trace_keepOutgoing_LoadGroup(refElem);
		};
	};
	-- keep outgoing references


	var refAllSubLoadArea_a64a7d7d_350f_463c_a921_64955586446d = __jointarget.objectsOfType(_jointarget::LoadGroup);
	refAllSubLoadArea_a64a7d7d_350f_463c_a921_64955586446d->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61970::LoadModel::LoadGroup)->collect(SubLoadArea)->selectByKind(_CIM::IEC61970::LoadModel::SubLoadArea)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_SubLoadArea(refElem.resolveone(_jointarget::SubLoadArea));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_SubLoadArea(refElem);
			}endif;
			refElem.resolveone(_jointarget::SubLoadArea).map trace_keepOutgoing_SubLoadArea(refElem);
		};
	};
	-- keep outgoing references


	var refAllLoadArea_e7774668_cc9d_4686_b7f1_06b24e0c5b06 = __jointarget.objectsOfType(_jointarget::SubLoadArea);
	refAllLoadArea_e7774668_cc9d_4686_b7f1_06b24e0c5b06->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61970::LoadModel::SubLoadArea)->collect(LoadArea)->selectByKind(_CIM::IEC61970::LoadModel::LoadArea)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_LoadArea(refElem.resolveone(_jointarget::LoadArea));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_LoadArea(refElem);
			}endif;
			refElem.resolveone(_jointarget::LoadArea).map trace_keepOutgoing_LoadArea(refElem);
		};
	};
	-- keep outgoing references


	var refAllControlArea_d0ed2ede_2dbb_4e58_87bc_f95563406428 = __jointarget.objectsOfType(_jointarget::LoadArea);
	refAllControlArea_d0ed2ede_2dbb_4e58_87bc_f95563406428->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61970::LoadModel::EnergyArea)->collect(ControlArea)->selectByKind(_CIM::IEC61970::ControlArea::ControlArea)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_ControlArea(refElem.resolveone(_jointarget::ControlArea));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_ControlArea(refElem);
			}endif;
			refElem.resolveone(_jointarget::ControlArea).map trace_keepOutgoing_ControlArea(refElem);
		};
	};
	-- keep outgoing references


	var refAllLoadGroup_fd23a660_8567_460b_87c8_691c27cec480 = __jointarget.objectsOfType(_jointarget::NonConformLoad);
	refAllLoadGroup_fd23a660_8567_460b_87c8_691c27cec480->forEach(elem) {
		elem.invresolve()->selectByKind(_CIM::IEC61970::LoadModel::NonConformLoad)->collect(LoadGroup)->selectByKind(_CIM::IEC61970::LoadModel::NonConformLoadGroup)->forEach(refElem) {
			-- if source object at the end of the reference has already been mapped, update the reference with the mapped element
			if (refElem.resolve()->notEmpty()) then {
				elem.map update_keepOutgoing_LoadGroup(refElem.resolveone(_jointarget::NonConformLoadGroup));
			-- if it has not been mapped yet, create new element and update reference
			} else {
				elem.map update_keepOutgoing_and_create_LoadGroup(refElem);
			}endif;
			refElem.resolveone(_jointarget::NonConformLoadGroup).map trace_keepOutgoing_LoadGroup(refElem);
		};
	};



	-- keep attributes
	var keepAttPMUApparentPowerMeter_caea0116_06f0_4145_b2de_5c19271d64b3 = __jointarget.objectsOfType(_jointarget::PMUApparentPowerMeter);
			keepAttPMUApparentPowerMeter_caea0116_06f0_4145_b2de_5c19271d64b3->forEach(elem) {
				var sourceClass = elem.invresolveone(_CIM::IEC61970::Core::IdentifiedObject);
				elem.map update_attribute_mRID(sourceClass.mRID)	
				};
	var keepAttPrivateMeterApparentPower_2ad098f7_3c24_4cee_900a_4367978938e7 = __jointarget.objectsOfType(_jointarget::PrivateMeterApparentPower);
			keepAttPrivateMeterApparentPower_2ad098f7_3c24_4cee_900a_4367978938e7->forEach(elem) {
				var sourceClass = elem.invresolveone(_COSEM::PhysicalDevice);
				elem.map update_attribute_ID(sourceClass.ID)	
				};
	var keepAttPositionPoint_e5c660ec_3560_4a05_8f21_a61199be95f5 = __jointarget.objectsOfType(_jointarget::PositionPoint);
			keepAttPositionPoint_e5c660ec_3560_4a05_8f21_a61199be95f5->forEach(elem) {
				var sourceClass = elem.invresolveone(_CIM::IEC61968::Common::PositionPoint);
				elem.map update_attribute_xPosition(sourceClass.xPosition)	
				};
			keepAttPositionPoint_e5c660ec_3560_4a05_8f21_a61199be95f5->forEach(elem) {
				var sourceClass = elem.invresolveone(_CIM::IEC61968::Common::PositionPoint);
				elem.map update_attribute_yPosition(sourceClass.yPosition)	
				};
			keepAttPositionPoint_e5c660ec_3560_4a05_8f21_a61199be95f5->forEach(elem) {
				var sourceClass = elem.invresolveone(_CIM::IEC61968::Common::PositionPoint);
				elem.map update_attribute_zPosition(sourceClass.zPosition)	
				};
	var keepAttControlArea_98ffd3c0_b7a2_4be5_8ffc_bba8ab4c8395 = __jointarget.objectsOfType(_jointarget::ControlArea);
			keepAttControlArea_98ffd3c0_b7a2_4be5_8ffc_bba8ab4c8395->forEach(elem) {
				var sourceClass = elem.invresolveone(_CIM::IEC61970::Core::IdentifiedObject);
				elem.map update_attribute_mRID(sourceClass.mRID)	
				};
	var keepAttEnergyConsumer_75e587af_9611_43e9_9e5f_3b74ae447d1d = __jointarget.objectsOfType(_jointarget::EnergyConsumer);
			keepAttEnergyConsumer_75e587af_9611_43e9_9e5f_3b74ae447d1d->forEach(elem) {
				var sourceClass = elem.invresolveone(_CIM::IEC61970::Core::IdentifiedObject);
				elem.map update_attribute_mRID(sourceClass.mRID)	
				};



	-- keep calculated
	var keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2 = __jointarget.objectsOfType(_jointarget::PMUApparentPowerMeter);
keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_substationStandard::LNNodes::LNGroupM::MMXU);
	elem.map update_attribute_ApparentPowerAMag(leftElement, rightElement)	
	};
keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_substationStandard::LNNodes::LNGroupM::MMXU);
	elem.map update_attribute_ApparentPowerAAng(leftElement, rightElement)	
	};
keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_substationStandard::LNNodes::LNGroupM::MMXU);
	elem.map update_attribute_ApparentPowerBMag(leftElement, rightElement)	
	};
keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_substationStandard::LNNodes::LNGroupM::MMXU);
	elem.map update_attribute_ApparentPowerBAng(leftElement, rightElement)	
	};
keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_substationStandard::LNNodes::LNGroupM::MMXU);
	elem.map update_attribute_ApparentPowerCMag(leftElement, rightElement)	
	};
keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_substationStandard::LNNodes::LNGroupM::MMXU);
	elem.map update_attribute_ApparentPowerCAng(leftElement, rightElement)	
	};
keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_substationStandard::LNNodes::LNGroupM::MMXU);
	elem.map update_attribute_ApparentPowerNeutMag(leftElement, rightElement)	
	};
keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_substationStandard::LNNodes::LNGroupM::MMXU);
	elem.map update_attribute_ApparentPowerNeutAng(leftElement, rightElement)	
	};
keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_substationStandard::LNNodes::LNGroupM::MMXU);
	elem.map update_attribute_ApparentPowerNetMag(leftElement, rightElement)	
	};
keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_substationStandard::LNNodes::LNGroupM::MMXU);
	elem.map update_attribute_ApparentPowerNetAng(leftElement, rightElement)	
	};
keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_substationStandard::LNNodes::LNGroupM::MMXU);
	elem.map update_attribute_ApparentPowerResMag(leftElement, rightElement)	
	};
keepAttPMUApparentPowerMeter_e2aa2500_e95d_4f24_a356_8454fbf837e2->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_substationStandard::LNNodes::LNGroupM::MMXU);
	elem.map update_attribute_ApparentPowerResAng(leftElement, rightElement)	
	};
	var keepAttPrivateMeterApparentPower_85c0b272_a237_44e7_a6ad_262a90393f71 = __jointarget.objectsOfType(_jointarget::PrivateMeterApparentPower);
keepAttPrivateMeterApparentPower_85c0b272_a237_44e7_a6ad_262a90393f71->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_COSEM::PhysicalDevice);
	elem.map update_attribute_ApparentPowerImportA(leftElement, rightElement)	
	};
keepAttPrivateMeterApparentPower_85c0b272_a237_44e7_a6ad_262a90393f71->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_COSEM::PhysicalDevice);
	elem.map update_attribute_ApparentPowerImportB(leftElement, rightElement)	
	};
keepAttPrivateMeterApparentPower_85c0b272_a237_44e7_a6ad_262a90393f71->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_COSEM::PhysicalDevice);
	elem.map update_attribute_ApparentPowerImportC(leftElement, rightElement)	
	};
keepAttPrivateMeterApparentPower_85c0b272_a237_44e7_a6ad_262a90393f71->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_COSEM::PhysicalDevice);
	elem.map update_attribute_ApparentPowerExportA(leftElement, rightElement)	
	};
keepAttPrivateMeterApparentPower_85c0b272_a237_44e7_a6ad_262a90393f71->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_COSEM::PhysicalDevice);
	elem.map update_attribute_ApparentPowerExportB(leftElement, rightElement)	
	};
keepAttPrivateMeterApparentPower_85c0b272_a237_44e7_a6ad_262a90393f71->forEach(elem) {
	var leftElement = elem.invresolveone(_CIM::IEC61968::Metering::MeterAsset);
	var rightElement =  elem.invresolveone(_COSEM::PhysicalDevice);
	elem.map update_attribute_ApparentPowerExportC(leftElement, rightElement)	
	};



	-- keep aggregates

	}
	
-- ##
-- # Natural Join Mappings
-- ##

-- ##
-- # Left Outer Join Mappings
-- ##
	
-- ##
-- # Theta Join Mappings
-- ##

-- mapping for PMUApparentPowerMeter
mapping _CIM::IEC61968::Metering::MeterAsset::thetaJoin_MeterAsset_MMXU_To_PMUApparentPowerMeter(rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) : _jointarget::PMUApparentPowerMeter 
when {
		self.mRID = rightElement.NamePlt.IdNs
}
{
		-- create the target instances
		end {
			rightElement.map thetaJoin_update_MMXU(result);
			result.map thetaJoin_trace_MMXU(self, rightElement)
		}
}

-- additional mapping for the right element, so that it appears in the QVT mapping table (for resolve)
mapping _substationStandard::LNNodes::LNGroupM::MMXU::thetaJoin_update_MMXU(rightElement : _jointarget::PMUApparentPowerMeter) : _jointarget::PMUApparentPowerMeter {
	init {
		result:=rightElement;
	}
}

-- create the trace class instance
mapping _jointarget::PMUApparentPowerMeter::thetaJoin_trace_MMXU(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) : _mjtrace::join_MeterAsset_MMXU_PMUApparentPowerMeter {
	left := leftElement;
	right := rightElement;
	target := self;
}


-- mapping for PrivateMeterApparentPower
mapping _CIM::IEC61968::Metering::MeterAsset::thetaJoin_MeterAsset_PhysicalDevice_To_PrivateMeterApparentPower(rightElement : _COSEM::PhysicalDevice) : _jointarget::PrivateMeterApparentPower 
when {
		self.mRID = rightElement.ID
}
{
		-- create the target instances
		end {
			rightElement.map thetaJoin_update_PhysicalDevice(result);
			result.map thetaJoin_trace_PhysicalDevice(self, rightElement)
		}
}

-- additional mapping for the right element, so that it appears in the QVT mapping table (for resolve)
mapping _COSEM::PhysicalDevice::thetaJoin_update_PhysicalDevice(rightElement : _jointarget::PrivateMeterApparentPower) : _jointarget::PrivateMeterApparentPower {
	init {
		result:=rightElement;
	}
}

-- create the trace class instance
mapping _jointarget::PrivateMeterApparentPower::thetaJoin_trace_PhysicalDevice(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _COSEM::PhysicalDevice) : _mjtrace::join_MeterAsset_PhysicalDevice_PrivateMeterApparentPower {
	left := leftElement;
	right := rightElement;
	target := self;
}


-- ##
-- # Keep outgoing Mappings
-- ##
-- mappings for Asset

-- set the links for "Location" if instances already exist
mapping inout _jointarget::Asset::update_keepOutgoing_Location(elem : _jointarget::Location) {
	self.Location:=elem;
}

-- set the links for "Location" if instances have to be created
mapping inout _jointarget::Asset::update_keepOutgoing_and_create_Location(elem : _CIM::IEC61968::Common::Location) {
	self.Location:=elem.map Location_Location_to_Location();
}

-- create instances of the type of "Location"
mapping _CIM::IEC61968::Common::Location::Location_Location_to_Location() : _jointarget::Location {
}

mapping _jointarget::Location::trace_keepOutgoing_Location(source : _CIM::IEC61968::Common::Location) : _mjtrace::ref_Location_Location_Location {
	result.source := source;
	result.target := self;
}

-- mappings for Location

-- set the links for "Position" if instances already exist
mapping inout _jointarget::Location::update_keepOutgoing_Position(elem : _jointarget::PositionPoint) {
	self.Position:=elem;
}

-- set the links for "Position" if instances have to be created
mapping inout _jointarget::Location::update_keepOutgoing_and_create_Position(elem : _CIM::IEC61968::Common::PositionPoint) {
	self.Position:=elem.map Position_PositionPoint_to_PositionPoint();
}

-- create instances of the type of "Position"
mapping _CIM::IEC61968::Common::PositionPoint::Position_PositionPoint_to_PositionPoint() : _jointarget::PositionPoint {
}

mapping _jointarget::PositionPoint::trace_keepOutgoing_Position(source : _CIM::IEC61968::Common::PositionPoint) : _mjtrace::ref_PositionPoint_PositionPoint_Position {
	result.source := source;
	result.target := self;
}

-- mappings for Location

-- set the links for "PowerSystemResources" if instances already exist
mapping inout _jointarget::Location::update_keepOutgoing_PowerSystemResources(elem : _jointarget::PowerSystemResource) {
	self.PowerSystemResources+=elem;
}

-- set the links for "PowerSystemResources" if instances have to be created
mapping inout _jointarget::Location::update_keepOutgoing_and_create_PowerSystemResources(elem : _CIM::IEC61970::Core::PowerSystemResource) {
	self.PowerSystemResources+=elem.map PowerSystemResources_PowerSystemResource_to_PowerSystemResource();
}

-- create instances of the type of "PowerSystemResources"
mapping _CIM::IEC61970::Core::PowerSystemResource::PowerSystemResources_PowerSystemResource_to_PowerSystemResource() : _jointarget::PowerSystemResource {
}

mapping _jointarget::PowerSystemResource::trace_keepOutgoing_PowerSystemResources(source : _CIM::IEC61970::Core::PowerSystemResource) : _mjtrace::ref_PowerSystemResource_PowerSystemResource_PowerSystemResources {
	result.source := source;
	result.target := self;
}

-- mappings for ConductingEquipment

-- set the links for "Terminals" if instances already exist
mapping inout _jointarget::ConductingEquipment::update_keepOutgoing_Terminals(elem : _jointarget::Terminal) {
	self.Terminals+=elem;
}

-- set the links for "Terminals" if instances have to be created
mapping inout _jointarget::ConductingEquipment::update_keepOutgoing_and_create_Terminals(elem : _CIM::IEC61970::Core::Terminal) {
	self.Terminals+=elem.map Terminals_Terminal_to_Terminal();
}

-- create instances of the type of "Terminals"
mapping _CIM::IEC61970::Core::Terminal::Terminals_Terminal_to_Terminal() : _jointarget::Terminal {
}

mapping _jointarget::Terminal::trace_keepOutgoing_Terminals(source : _CIM::IEC61970::Core::Terminal) : _mjtrace::ref_Terminal_Terminal_Terminals {
	result.source := source;
	result.target := self;
}

-- mappings for Terminal

-- set the links for "TieFlow" if instances already exist
mapping inout _jointarget::Terminal::update_keepOutgoing_TieFlow(elem : _jointarget::TieFlow) {
	self.TieFlow+=elem;
}

-- set the links for "TieFlow" if instances have to be created
mapping inout _jointarget::Terminal::update_keepOutgoing_and_create_TieFlow(elem : _CIM::IEC61970::ControlArea::TieFlow) {
	self.TieFlow+=elem.map TieFlow_TieFlow_to_TieFlow();
}

-- create instances of the type of "TieFlow"
mapping _CIM::IEC61970::ControlArea::TieFlow::TieFlow_TieFlow_to_TieFlow() : _jointarget::TieFlow {
}

mapping _jointarget::TieFlow::trace_keepOutgoing_TieFlow(source : _CIM::IEC61970::ControlArea::TieFlow) : _mjtrace::ref_TieFlow_TieFlow_TieFlow {
	result.source := source;
	result.target := self;
}

-- mappings for TieFlow

-- set the links for "ControlArea" if instances already exist
mapping inout _jointarget::TieFlow::update_keepOutgoing_ControlArea(elem : _jointarget::ControlArea) {
	self.ControlArea:=elem;
}

-- set the links for "ControlArea" if instances have to be created
mapping inout _jointarget::TieFlow::update_keepOutgoing_and_create_ControlArea(elem : _CIM::IEC61970::ControlArea::ControlArea) {
	self.ControlArea:=elem.map ControlArea_ControlArea_to_ControlArea();
}

-- create instances of the type of "ControlArea"
mapping _CIM::IEC61970::ControlArea::ControlArea::ControlArea_ControlArea_to_ControlArea() : _jointarget::ControlArea {
}

mapping _jointarget::ControlArea::trace_keepOutgoing_ControlArea(source : _CIM::IEC61970::ControlArea::ControlArea) : _mjtrace::ref_ControlArea_ControlArea_ControlArea {
	result.source := source;
	result.target := self;
}

-- mappings for EndDeviceAsset

-- set the links for "ServiceDeliveryPoint" if instances already exist
mapping inout _jointarget::EndDeviceAsset::update_keepOutgoing_ServiceDeliveryPoint(elem : _jointarget::ServiceDeliveryPoint) {
	self.ServiceDeliveryPoint:=elem;
}

-- set the links for "ServiceDeliveryPoint" if instances have to be created
mapping inout _jointarget::EndDeviceAsset::update_keepOutgoing_and_create_ServiceDeliveryPoint(elem : _CIM::IEC61968::Metering::ServiceDeliveryPoint) {
	self.ServiceDeliveryPoint:=elem.map ServiceDeliveryPoint_ServiceDeliveryPoint_to_ServiceDeliveryPoint();
}

-- create instances of the type of "ServiceDeliveryPoint"
mapping _CIM::IEC61968::Metering::ServiceDeliveryPoint::ServiceDeliveryPoint_ServiceDeliveryPoint_to_ServiceDeliveryPoint() : _jointarget::ServiceDeliveryPoint {
}

mapping _jointarget::ServiceDeliveryPoint::trace_keepOutgoing_ServiceDeliveryPoint(source : _CIM::IEC61968::Metering::ServiceDeliveryPoint) : _mjtrace::ref_ServiceDeliveryPoint_ServiceDeliveryPoint_ServiceDeliveryPoint {
	result.source := source;
	result.target := self;
}

-- mappings for ServiceDeliveryPoint

-- set the links for "EnergyConsumer" if instances already exist
mapping inout _jointarget::ServiceDeliveryPoint::update_keepOutgoing_EnergyConsumer(elem : _jointarget::EnergyConsumer) {
	self.EnergyConsumer:=elem;
}

-- set the links for "EnergyConsumer" if instances have to be created
mapping inout _jointarget::ServiceDeliveryPoint::update_keepOutgoing_and_create_EnergyConsumer(elem : _CIM::IEC61970::Wires::EnergyConsumer) {
	self.EnergyConsumer:=elem.map EnergyConsumer_EnergyConsumer_to_EnergyConsumer();
}

-- create instances of the type of "EnergyConsumer"
mapping _CIM::IEC61970::Wires::EnergyConsumer::EnergyConsumer_EnergyConsumer_to_EnergyConsumer() : _jointarget::EnergyConsumer {
}

mapping _jointarget::EnergyConsumer::trace_keepOutgoing_EnergyConsumer(source : _CIM::IEC61970::Wires::EnergyConsumer) : _mjtrace::ref_EnergyConsumer_EnergyConsumer_EnergyConsumer {
	result.source := source;
	result.target := self;
}

-- mappings for ConformLoad

-- set the links for "LoadGroup" if instances already exist
mapping inout _jointarget::ConformLoad::update_keepOutgoing_LoadGroup(elem : _jointarget::ConformLoadGroup) {
	self.LoadGroup:=elem;
}

-- set the links for "LoadGroup" if instances have to be created
mapping inout _jointarget::ConformLoad::update_keepOutgoing_and_create_LoadGroup(elem : _CIM::IEC61970::LoadModel::ConformLoadGroup) {
	self.LoadGroup:=elem.map LoadGroup_ConformLoadGroup_to_ConformLoadGroup();
}

-- create instances of the type of "LoadGroup"
mapping _CIM::IEC61970::LoadModel::ConformLoadGroup::LoadGroup_ConformLoadGroup_to_ConformLoadGroup() : _jointarget::ConformLoadGroup {
}

mapping _jointarget::ConformLoadGroup::trace_keepOutgoing_LoadGroup(source : _CIM::IEC61970::LoadModel::ConformLoadGroup) : _mjtrace::ref_ConformLoadGroup_ConformLoadGroup_LoadGroup {
	result.source := source;
	result.target := self;
}

-- mappings for LoadGroup

-- set the links for "SubLoadArea" if instances already exist
mapping inout _jointarget::LoadGroup::update_keepOutgoing_SubLoadArea(elem : _jointarget::SubLoadArea) {
	self.SubLoadArea:=elem;
}

-- set the links for "SubLoadArea" if instances have to be created
mapping inout _jointarget::LoadGroup::update_keepOutgoing_and_create_SubLoadArea(elem : _CIM::IEC61970::LoadModel::SubLoadArea) {
	self.SubLoadArea:=elem.map SubLoadArea_SubLoadArea_to_SubLoadArea();
}

-- create instances of the type of "SubLoadArea"
mapping _CIM::IEC61970::LoadModel::SubLoadArea::SubLoadArea_SubLoadArea_to_SubLoadArea() : _jointarget::SubLoadArea {
}

mapping _jointarget::SubLoadArea::trace_keepOutgoing_SubLoadArea(source : _CIM::IEC61970::LoadModel::SubLoadArea) : _mjtrace::ref_SubLoadArea_SubLoadArea_SubLoadArea {
	result.source := source;
	result.target := self;
}

-- mappings for SubLoadArea

-- set the links for "LoadArea" if instances already exist
mapping inout _jointarget::SubLoadArea::update_keepOutgoing_LoadArea(elem : _jointarget::LoadArea) {
	self.LoadArea:=elem;
}

-- set the links for "LoadArea" if instances have to be created
mapping inout _jointarget::SubLoadArea::update_keepOutgoing_and_create_LoadArea(elem : _CIM::IEC61970::LoadModel::LoadArea) {
	self.LoadArea:=elem.map LoadArea_LoadArea_to_LoadArea();
}

-- create instances of the type of "LoadArea"
mapping _CIM::IEC61970::LoadModel::LoadArea::LoadArea_LoadArea_to_LoadArea() : _jointarget::LoadArea {
}

mapping _jointarget::LoadArea::trace_keepOutgoing_LoadArea(source : _CIM::IEC61970::LoadModel::LoadArea) : _mjtrace::ref_LoadArea_LoadArea_LoadArea {
	result.source := source;
	result.target := self;
}

-- mappings for LoadArea

-- set the links for "ControlArea" if instances already exist
mapping inout _jointarget::LoadArea::update_keepOutgoing_ControlArea(elem : _jointarget::ControlArea) {
	self.ControlArea:=elem;
}

-- set the links for "ControlArea" if instances have to be created
mapping inout _jointarget::LoadArea::update_keepOutgoing_and_create_ControlArea(elem : _CIM::IEC61970::ControlArea::ControlArea) {
	self.ControlArea:=elem.map ControlArea_ControlArea_to_ControlArea();
}

-- create instances of the type of "ControlArea"
/*mapping _CIM::IEC61970::ControlArea::ControlArea::ControlArea_ControlArea_to_ControlArea() : _jointarget::ControlArea {
}

mapping _jointarget::ControlArea::trace_keepOutgoing_ControlArea(source : _CIM::IEC61970::ControlArea::ControlArea) : _mjtrace::ref_ControlArea_ControlArea_ControlArea {
	result.source := source;
	result.target := self;
}*/

-- mappings for NonConformLoad

-- set the links for "LoadGroup" if instances already exist
mapping inout _jointarget::NonConformLoad::update_keepOutgoing_LoadGroup(elem : _jointarget::NonConformLoadGroup) {
	self.LoadGroup:=elem;
}

-- set the links for "LoadGroup" if instances have to be created
mapping inout _jointarget::NonConformLoad::update_keepOutgoing_and_create_LoadGroup(elem : _CIM::IEC61970::LoadModel::NonConformLoadGroup) {
	self.LoadGroup:=elem.map LoadGroup_NonConformLoadGroup_to_NonConformLoadGroup();
}

-- create instances of the type of "LoadGroup"
mapping _CIM::IEC61970::LoadModel::NonConformLoadGroup::LoadGroup_NonConformLoadGroup_to_NonConformLoadGroup() : _jointarget::NonConformLoadGroup {
}

mapping _jointarget::NonConformLoadGroup::trace_keepOutgoing_LoadGroup(source : _CIM::IEC61970::LoadModel::NonConformLoadGroup) : _mjtrace::ref_NonConformLoadGroup_NonConformLoadGroup_LoadGroup {
	result.source := source;
	result.target := self;
}


-- ##
-- # Keep incoming Mappings
-- ##
-- ##
-- # Keep attribute Mappings
-- ##
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_mRID(attValue : String) {
	self.mRID:=attValue;
}
mapping inout _jointarget::PrivateMeterApparentPower::update_attribute_ID(attValue : String) {
	self.ID:=attValue;
}
mapping inout _jointarget::PositionPoint::update_attribute_xPosition(attValue : String) {
	self.xPosition:=attValue;
}
mapping inout _jointarget::PositionPoint::update_attribute_yPosition(attValue : String) {
	self.yPosition:=attValue;
}
mapping inout _jointarget::PositionPoint::update_attribute_zPosition(attValue : String) {
	self.zPosition:=attValue;
}
mapping inout _jointarget::ControlArea::update_attribute_mRID(attValue : String) {
	self.mRID:=attValue;
}
mapping inout _jointarget::EnergyConsumer::update_attribute_mRID(attValue : String) {
	self.mRID:=attValue;
}
mapping inout _jointarget::ConformLoad::update_attribute_mRID(attValue : String) {
	self.mRID:=attValue;
}
mapping inout _jointarget::NonConformLoad::update_attribute_mRID(attValue : String) {
	self.mRID:=attValue;
}

-- ##
-- # Keep calculated Mappings
-- ##
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_ApparentPowerAMag(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) {
	self.ApparentPowerAMag:=rightElement.VA.phsA.cVal.mag.f;
}
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_ApparentPowerAAng(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) {
	self.ApparentPowerAAng:=rightElement.VA.phsA.cVal.ang.f;
}
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_ApparentPowerBMag(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) {
	self.ApparentPowerBMag:=rightElement.VA.phsB.cVal.mag.f;
}
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_ApparentPowerBAng(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) {
	self.ApparentPowerBAng:=rightElement.VA.phsB.cVal.ang.f;
}
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_ApparentPowerCMag(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) {
	self.ApparentPowerCMag:=rightElement.VA.phsC.cVal.mag.f;
}
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_ApparentPowerCAng(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) {
	self.ApparentPowerCAng:=rightElement.VA.phsC.cVal.ang.f;
}
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_ApparentPowerNeutMag(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) {
	self.ApparentPowerNeutMag:=rightElement.VA.neut.cVal.mag.f;
}
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_ApparentPowerNeutAng(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) {
	self.ApparentPowerNeutAng:=rightElement.VA.neut.cVal.ang.f;
}
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_ApparentPowerNetMag(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) {
	self.ApparentPowerNetMag:=rightElement.VA.net.cVal.mag.f;
}
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_ApparentPowerNetAng(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) {
	self.ApparentPowerNetAng:=rightElement.VA.net.cVal.ang.f;
}
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_ApparentPowerResMag(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) {
	self.ApparentPowerResMag:=rightElement.VA.res.cVal.mag.f;
}
mapping inout _jointarget::PMUApparentPowerMeter::update_attribute_ApparentPowerResAng(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _substationStandard::LNNodes::LNGroupM::MMXU) {
	self.ApparentPowerResAng:=rightElement.VA.res.cVal.ang.f;
}
mapping inout _jointarget::PrivateMeterApparentPower::update_attribute_ApparentPowerImportA(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _COSEM::PhysicalDevice) {
	self.ApparentPowerImportA:=rightElement.ElectricityValues.ApparentPowermL1;
}
mapping inout _jointarget::PrivateMeterApparentPower::update_attribute_ApparentPowerImportB(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _COSEM::PhysicalDevice) {
	self.ApparentPowerImportB:=rightElement.ElectricityValues.ApparentPowermL2;
}
mapping inout _jointarget::PrivateMeterApparentPower::update_attribute_ApparentPowerImportC(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _COSEM::PhysicalDevice) {
	self.ApparentPowerImportC:=rightElement.ElectricityValues.ApparentPowermL3;
}
mapping inout _jointarget::PrivateMeterApparentPower::update_attribute_ApparentPowerExportA(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _COSEM::PhysicalDevice) {
	self.ApparentPowerExportA:=rightElement.ElectricityValues.ApparentPowerpL1;
}
mapping inout _jointarget::PrivateMeterApparentPower::update_attribute_ApparentPowerExportB(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _COSEM::PhysicalDevice) {
	self.ApparentPowerExportB:=rightElement.ElectricityValues.ApparentPowerpL2;
}
mapping inout _jointarget::PrivateMeterApparentPower::update_attribute_ApparentPowerExportC(leftElement : _CIM::IEC61968::Metering::MeterAsset, rightElement : _COSEM::PhysicalDevice) {
	self.ApparentPowerExportC:=rightElement.ElectricityValues.ApparentPowerpL3;
}



-- ##
-- # Keep aggregate Mappings
-- ##
